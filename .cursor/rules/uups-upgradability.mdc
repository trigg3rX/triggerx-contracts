---
alwaysApply: false
---
## üìå 2Ô∏è‚É£ OpenZeppelifolln UUPS Storage Layout

OpenZeppelin's `UUPSUpgradeable` uses these **hardcoded slots**:

```solidity
// ERC1967 Implementation slot
bytes32 private constant ERC1967_IMPLEMENTATION_SLOT = 
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

// ERC1822 Proxiable UUID
bytes32 private constant PROXIABLE_UUID = 
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
```

**These slots are safe and won't conflict with your storage.**

---

## üìå 3Ô∏è‚É£ LayerZero OApp Storage Layout

LayerZero's `OApp` base contract uses storage for:

```solidity
// From OAppCore
address public endpoint;                    // Slot 0
mapping(uint32 => bytes32) public peers;   // Slot 1

// From OApp  
mapping(uint32 => Config) public config;   // Slot 2
mapping(uint32 => Config) public defaultConfig; // Slot 3
```

**These come from: `OAppCore` ‚Üí `OApp` ‚Üí your contract**

---

## üìå 4Ô∏è‚É£ üß© Safe Pattern: OApp + UUPS + Ownable

### ‚úÖ Correct Inheritance Order

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@layerzerolabs/solidity-examples/contracts/oapp/OApp.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyLayerZeroUUPS is 
    OApp, 
    UUPSUpgradeable, 
    OwnableUpgradeable 
{
    // ============ STORAGE LAYOUT ============
    // Slot 0-3: OApp storage (endpoint, peers, config, defaultConfig)
    // Slot 4+: Your custom storage variables
    // UUPS uses hardcoded ERC1967 slots (safe)
    
    uint256 public myValue;           // Slot 4
    mapping(address => bool) public isAuthorized; // Slot 5
    string public version;            // Slot 6
    
    // ============ EVENTS ============
    event ValueUpdated(uint256 oldValue, uint256 newValue);
    event VersionUpdated(string oldVersion, string newVersion);
    
    // ============ CONSTRUCTOR ============
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor(address _endpoint) OApp(_endpoint) {
        // Only set immutable values here
        // The proxy won't run this constructor
    }
    
    // ============ INITIALIZER ============
    function initialize(
        address initialOwner,
        uint256 initialValue,
        string memory initialVersion
    ) external initializer {
        __Ownable_init(initialOwner);
        __UUPSUpgradeable_init();
        
        myValue = initialValue;
        version = initialVersion;
    }
    
    // ============ UUPS AUTHORIZATION ============
    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyOwner 
    {
        // Only owner can upgrade
        // Add any additional checks here
    }
    
    // ============ CUSTOM FUNCTIONS ============
    function setMyValue(uint256 newValue) external onlyOwner {
        uint256 oldValue = myValue;
        myValue = newValue;
        emit ValueUpdated(oldValue, newValue);
    }
    
    function setVersion(string memory newVersion) external onlyOwner {
        string memory oldVersion = version;
        version = newVersion;
        emit VersionUpdated(oldVersion, newVersion);
    }
    
    // ============ LAYERZERO FUNCTIONS ============
    function _lzReceive(
        Origin calldata _origin,
        bytes32 _guid,
        bytes calldata _message,
        address _executor,
        bytes calldata _extraData
    ) internal override {
        // Handle incoming LayerZero messages
        // Your cross-chain logic here
    }
    
    function sendMessage(
        uint32 _dstEid,
        bytes calldata _message,
        bytes calldata _options
    ) external payable {
        // Send cross-chain message
        _lzSend(_dstEid, _message, _options, payable(msg.sender), address(0), "");
    }
}
```

---

## ‚úÖ Key Safety Practices

### 1Ô∏è‚É£ **Inheritance Order is Critical**
```solidity
// ‚úÖ CORRECT: OApp first, then UUPS
contract MyContract is OApp, UUPSUpgradeable, OwnableUpgradeable

// ‚ùå WRONG: UUPS before OApp
contract MyContract is UUPSUpgradeable, OApp, OwnableUpgradeable
```

### 2Ô∏è‚É£ **Storage Layout Rules**
- **OApp storage:** Slots 0-3 (automatic)
- **Your storage:** Slots 4+ (append only)
- **UUPS storage:** Hardcoded ERC1967 slots (safe)

### 3Ô∏è‚É£ **Never Reorder Variables**
```solidity
// ‚úÖ CORRECT: Append new variables at the end
contract V1 {
    uint256 public value1;    // Slot 4
    uint256 public value2;    // Slot 5
}

contract V2 {
    uint256 public value1;    // Slot 4 (SAME)
    uint256 public value2;    // Slot 5 (SAME)
    uint256 public value3;    // Slot 6 (NEW)
}

// ‚ùå WRONG: Reordering breaks storage layout
contract V2 {
    uint256 public value2;    // Slot 4 (CHANGED!)
    uint256 public value1;    // Slot 5 (CHANGED!)
    uint256 public value3;    // Slot 6
}
```

### 4Ô∏è‚É£ **Proper Initialization**
```solidity
// ‚úÖ CORRECT: Use initializer modifier
function initialize() external initializer {
    __Ownable_init();
    __UUPSUpgradeable_init();
}

// ‚ùå WRONG: Don't use constructor for initialization
constructor() {
    __Ownable_init(); // This won't work with proxy
}
```

### 5Ô∏è‚É£ **Constructor Safety**
```solidity
// ‚úÖ CORRECT: Only immutable values in constructor
/// @custom:oz-upgrades-unsafe-allow constructor
constructor(address _endpoint) OApp(_endpoint) {
    // Only set immutable values
}

// ‚ùå WRONG: Don't initialize state in constructor
constructor(address _endpoint) OApp(_endpoint) {
    myValue = 100; // This won't persist in proxy
}
```

---

## ‚ö†Ô∏è Common Mistakes to Avoid

### üö´ **Deploy OApp Directly**
```solidity
// ‚ùå WRONG: Deploy implementation directly
MyLayerZeroUUPS contract = new MyLayerZeroUUPS(endpoint);

// ‚úÖ CORRECT: Deploy through proxy
ERC1967Proxy proxy = new ERC1967Proxy(
    address(implementation),
    abi.encodeWithSelector(
        MyLayerZeroUUPS.initialize.selector,
        owner,
        initialValue,
        initialVersion
    )
);
```

### üö´ **Mix Constructor with Initialization**
```solidity
// ‚ùå WRONG: Initialize state in constructor
constructor(address _endpoint) OApp(_endpoint) {
    myValue = 100; // Won't work with proxy
    __Ownable_init(); // Won't work with proxy
}

// ‚úÖ CORRECT: Use initializer function
function initialize() external initializer {
    myValue = 100; // Works with proxy
    __Ownable_init(); // Works with proxy
}
```

### üö´ **Forget Access Control**
```solidity
// ‚ùå WRONG: No access control on upgrade
function _authorizeUpgrade(address newImplementation) internal override {
    // Anyone can upgrade!
}

// ‚úÖ CORRECT: Proper access control
function _authorizeUpgrade(address newImplementation) 
    internal 
    override 
    onlyOwner 
{
    // Only owner can upgrade
}
```

---

## üü¢ Tools and Verification

### 1Ô∏è‚É£ **OpenZeppelin Upgrades Plugin**
```bash
# Install
npm install --save-dev @openzeppelin/hardhat-upgrades

# Hardhat config
require('@openzeppelin/hardhat-upgrades');

# Deploy with proxy
const { deployProxy } = require('@openzeppelin/hardhat-upgrades');
const contract = await deployProxy(MyLayerZeroUUPS, [endpoint, owner, value, version]);
```

### 2Ô∏è‚É£ **Storage Layout Verification**
```bash
# Compare storage layouts
npx hardhat storage-layout

# Check for conflicts
npx hardhat verify-storage-layout
```

### 3Ô∏è‚É£ **Foundry Integration**
```solidity
// In your test
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

function testUpgrade() public {
    // Deploy implementation
    MyLayerZeroUUPS impl = new MyLayerZeroUUPS(endpoint);
    
    // Deploy proxy
    bytes memory initData = abi.encodeWithSelector(
        MyLayerZeroUUPS.initialize.selector,
        owner,
        initialValue,
        initialVersion
    );
    
    ERC1967Proxy proxy = new ERC1967Proxy(address(impl), initData);
    MyLayerZeroUUPS contract = MyLayerZeroUUPS(address(proxy));
}
```

---

## üìã Deployment Checklist

### Pre-Deployment
- [ ] Verify inheritance order: `OApp, UUPSUpgradeable, OwnableUpgradeable`
- [ ] Use `@custom:oz-upgrades-unsafe-allow constructor` annotation
- [ ] Implement `_authorizeUpgrade` with proper access control
- [ ] Use `initializer` modifier for initialization function
- [ ] Test storage layout compatibility

### Deployment
- [ ] Deploy implementation contract
- [ ] Deploy ERC1967Proxy with initialization data
- [ ] Verify proxy points to correct implementation
- [ ] Test all functions work through proxy

### Post-Deployment
- [ ] Verify storage layout matches expectations
- [ ] Test upgrade functionality
- [ ] Verify LayerZero functions work correctly
- [ ] Monitor for any storage conflicts

---

## üîß Example Upgrade Script

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Script} from "forge-std/Script.sol";
import {MyLayerZeroUUPS} from "../src/MyLayerZeroUUPS.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

contract UpgradeScript is Script {
    function run() public {
        address proxyAddress = vm.envAddress("PROXY_ADDRESS");
        address newImplementation = vm.envAddress("NEW_IMPLEMENTATION");
        
        // Verify current state
        MyLayerZeroUUPS proxy = MyLayerZeroUUPS(proxyAddress);
        console.log("Current version:", proxy.version());
        console.log("Current value:", proxy.myValue());
        
        // Perform upgrade
        vm.startBroadcast();
        proxy.upgradeToAndCall(newImplementation, "");
        vm.stopBroadcast();
        
        // Verify upgrade
        console.log("New version:", proxy.version());
        console.log("New value:", proxy.myValue());
    }
}
```

---

## üö® Emergency Procedures

### If Storage Layout Breaks
1. **Immediately rollback** to previous implementation
2. **Analyze storage layout** differences
3. **Fix storage ordering** in new implementation
4. **Test thoroughly** before re-deploying

### If Upgrade Fails
1. **Check access control** - ensure caller is authorized
2. **Verify implementation** address is correct
3. **Check gas limits** for upgrade transaction
4. **Review initialization** data format

---

## üìö Additional Resources

- [OpenZeppelin UUPS Documentation](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable)
- [LayerZero OApp Documentation](https://docs.layerzero.network/contracts/oapp)
- [Storage Layout Guide](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#storage-gaps)

---

**Remember: Storage layout bugs are irreversible. Always test upgrades on testnets first!** 